---
title: "2.1 - Objects"
author: "Jonny Saunders"
date: "October 5, 2017"
output: 
  md_document:
    preserve_yaml: true
    toc: true
    toc_depth: 2
order: 2
---

# What are Objects?

Objects are, roughly, data (or more generally a stored state) that knows what it can do. 

We know what happens when we put this troublesome `+` guy between numbers

```{r}
1 + 1 # ud better b sitting down
```

But it's less clear what it means to `+` letters

```{r, error=TRUE}
"a" + "b"
```

Let's see what `typeof` variables `1` and `"a"` are  :
```{r}
typeof(1)
typeof("a")
```
>(note this is a little misleading, `typeof` determines the base object class that an R object is stored as. All R objects are composed of base objects, we'll get to the types of objects in the next section)


## Object terminology
A **class** is the description, or 'blueprint' of how individual **objects** or **instances** are made, including their **attributes** - which data should be kept and what it should be named, and **methods**, the functions that they are capable of calling on their stored data or attributes. Objects can have a nested structure, and sub-classes can **inherit** the attributes and methods of their parent classes.

For example: As a class, trucks have attributes like engine_size, number_of_wheels, or number_of_jumps_gone_off. Trucks have the method go_faster(), but only individual instances of trucks can go_faster() - the concept/class of trucks can't. As a subclass, monster_trucks also have the attributes engine_size, etc. and the method go_faster(), but they also have additional attributes like mythical_backstory and methods like monster_jam().

# Objects in R
>"In R functions are objects and can be manipulated in much the same way as any other object." - *R language guide 2.1.5*

>"S3 objects are functions that call the functions of their objects" - *Also R*


R has base types and three object-oriented systems. We'll spend more time on Base types and S3 objects in this lesson, and return to S4 and reference classes when we start building bigger code.


* **Base types:** Low-level C types. Build the other object systems.

* **S3 - "Casual objects":** Objects that use **generic functions**. S3 methods "belong to" functions, not classes. Functions contain the **UseMethod("function_name", object)** function (see `?UseMethod`).

* **S4 - "Formal objects":** Formal classes with inheritance and means by which methods can be shared between classes. S4 methods still "belong to" functions, but classes are more rigorously defined. 

* **Reference classes:** Objects that use **message passing** - or the method 'belongs to' the object instance rather than the class.

The easiest way to see everything about an object is to use the str() function, short for structure. For example we can see everything about the lamest linear model ever
```{r}
lame_model <- lm(c(1,2,3) ~ c(4,5,6))
str(lame_model)
```

R has a useful package `pryr` for inspecting objects and other meta-linguistic needs. Let's get that now.
```{r}
# install.packages("pryr")
```

We can query any object's type with pryr's `otype`
```{r}
pryr::otype(c(1,2,3,4,5)) # A vector is a base object
pryr::otype(data.frame(x=c(1,2,3,4,5))) # A dataframe is an S3 object
```

# Base Types
Every R object is built out of basic C structures that define how it is stored and managed in memory.

This table from [Advanced R](http://adv-r.had.co.nz/Data-structures.html#data-structures) summarizes them:

| | Homogenous data | Heterogenous data |
|------------|----------------| ------------------|
| 1-Dimensional | Atomic Vector | List |
| 2-Dimensional | Matrix | Data frame |
| N-Dimensional | Array | |

Recall that we can use `typeof()` to find an object's base type
```{r}
typeof(1)
typeof(list(1,2,3))
```



## Vectors

Vectors are sequences, the most basic data type in R. They have two varieties: **atomic vectors** (with homogenous values) and **lists** (with ... heterogenous values). 

R has no 0-dimensional, scalar types, so individual characters or numbers are length=one atomic vectors. They are:

| Atomic Vector Type | Example | 
| ------------------ | ------- |
| Logical   | `booleans <- c(TRUE, FALSE, NA)` |
| Integer   | `integers <- c(1L, 2L, 3L)`  |
| Double    | `doubles <- c(1, 2.5, 0.005)` |
| Character | `characters <- c("apple", "banana")` |

`raw` and `complex` types also exist, but they are rare.

Vectors are constructed with `c()`. When heterogeneous vectors are constructed with `c()`, they are *coerced* to the most permissive vector type (an integer can be both a double (floating point numbers with decimal points) and character "1") - the table above is ordered from least to most permissive.

```{r}
vect_1 <- c(1L, 2L, 3L)
vect_2 <- c(1L, 2L, 3)
vect_3 <- c(1L,2,"3")

typeof(vect_1)
typeof(vect_2)
typeof(vect_3)

# We select elements of vectors with [] notation
vect_1[1]
vect_3[1]

```

To make a vector that preserves the types of its elements, make a `list` instead
```{r}
a_list <- list(1L,2,"3")
a_list
typeof(a_list[[1]])
typeof(a_list[[2]])
typeof(a_list[[3]])
```

Notice the double bracket notation `[[]]`. Lists are commonly recursive, ie. they store other lists. Since the elements of our list are themselves lists, single bracket indexing `[]` returns lists, and `[[]]` returns the the elements in that list.

```{r}
is.recursive(a_list)
a_list[1]
typeof(a_list[1])

# Indexing recursive lists
b_list <- list(1:3, c("apple", "banana", "cucumber"))
b_list
b_list[1]
b_list[1][1]
b_list[[1]]
b_list[[1]][1]
```

Similarly to coersion among atomic vectors, vectors that contain lists will be coerced to lists.
```{r}
c(1,2,3)
c(c(1),c(2,3))
c(c(1),list(2,3))
list(c(1,2,3), c("a","b","c"))

# Unlist turns lists back into (flat) atomic vectors
unlist(list(c(1,2,3), c("a","b","c")))
```

Because they are the most general form of vector, lists are used as the base type for many derived classes, like data frames
```{r}
typeof(data.frame(c(1,2,3)))
```

## Matrices & Arrays
**Arrays** are atomic vectors with a `dim` attribute (more about attributes in 2.2). **Matrices** are arrays with `dim = 2`. 

```{r}
array_1 <- array(1:24, dim=c(2,3,4))
array_2 <- matrix(1:24, ncol=3, nrow=8)
array_3 <- c(1:24)
dim(array_3) <- c(2,3,4)
# or attr(array_3, "dim") <- c(2,3,4)
```

In higher dimensions, c() becomes `cbind(), rbind()`, and `abind()`; column and row bind for matrices and array bind for arrays.
```{r}
by_columns <- cbind(c(1,2,3), c(4,5,6), c(7,8,9))
by_columns
by_rows <- rbind(c(1,2,3), c(4,5,6), c(7,8,9))
by_rows

abind::abind(by_columns, by_rows, along=1)
abind::abind(by_columns, by_rows, along=2)
abind::abind(by_columns, by_rows, along=3)
```

## Data Frames
Data frames are one of the gems of R. A data frame is a list of equal length vectors. 

```{r}
df <- data.frame(little_ones = c(0,1,2,3,4),
                 big_ones = c(5,6,7,8,9))
df
```

dfs can be used like lists of vectors
```{r}
df[1]
df[[1]]
df[[1]][1] # as above
```

Or using `names`, which we'll cover in more detail in 2.2. In short, the `$` operator allows us to index by an object's `names`. see `?Extract` for more information.

```{r}
names(df)
colnames(df)
rownames(df)

df$little_ones 
df$big_ones
```

Data frames also inherit the methods of lists and vectors

```{r}
df2 <- data.frame(medium_ones = c(3,4,5,6,7))
cbind(df, df2)

df_squared <- cbind(df2, df2)
names(df_squared) <- names(df)
rbind(df,df_squared)
```



```


## Etc.

Functions, environments, and other stuff that we'll learn about in our section on Functions are also base objects, but we'll discuss them then.


# S3 Objects
S3 objects "belong to" functions, S4 objects "have" functions (methods). S3 classes don't really "exist," but are assigned as an object's "class" attribute.

```{r, echo=TRUE}
x <- 1
attr(x, "class")
class(x) <- "letters"
attr(x, "class")
```

One can find an articulation of the reasoning behind this "function-and-class" programming can be found here: https://developer.r-project.org/howMethodsWork.pdf


S3 objects are defined by a series of functions that themselves contain the `UseMethod()` function - this is described briefly above, try `?UseMethod` for more detail. These functions extend the generic function, typically using the syntax `generic.class()` as in the case of `mean.Date()` for taking the mean of dates. One can list the objects that have a generic method, and the methods that an object has with `methods()`

```{r}
methods(mean)

methods(class="Date")
```


By default, the source code of S3 methods is not visible to R, one can retreive it with `utils::getS3method``

The `plot` base function is an s3 generic method.
```{r}
pryr::ftype(plot) # get a function's type
```

By default, if the first argument is a base type compatible with being points on a scatterplot, the actual function that is called is `plot.default`, whose source behaves like you'd expect:

```{r}
plot.default
```

If the first argument to `plot` has its own `plot` method (ie. that it is exported by the object's package namespace, more about this in section 5), that function is called instead. That's why 

```{r}
aq <- datasets::airquality
plot(lm(Ozone ~ Month, data=aq))
```

is different than this nonsensical model

```{r}
plot(lme4::lmer(Ozone ~ 0 + (Day | Month), data=aq))
```

## Example: Extending S3 Objects
> http://adv-r.had.co.nz/OO-essentials.html "Creating new methods and generics"

```{r, error=TRUE}
pryr::ftype(mean) # mean is an s3 generic function


x <- 1
class(x) <- "just_one"

# We give our "just_one" class a mean method:
mean.just_one <- function(x, ...) print("that's just a one you maniac")

# Mean behaves like it should for numbers and lists of numbers
mean(1)
mean(c(1,1.5))

# Other objects have their own mean() method
methods(mean)

# like Date objects
dates <- c("01jan2000","15jan2000")
attr(dates,"class")
mean(dates) # Don't work


# turn it into "Date" object
dates <- as.Date(dates, "%d%b%Y") # base has a set of "as" methods to convert types
attr(dates,"class")
mean(dates) # will call its method

mean.Date(dates) # which can also be called directly
```



# S4 Objects
S4 objects have a single class definition with specifically defined fields and functions. They are too complicated for us to cover in much detail yet, so we will return to them again later.

We could pretend for awhile we're another class with S3 objects

```{r, error=TRUE}
a <- data.frame(a="test")
class(a)
class(a) <- "lm"
a
summary(a)
```

Not so with S4 objects.

We can finally implement our truck classes
```{r}
setClass("truck",
  slots = list(engine_size = "numeric",
    n_wheels = "numeric",
    n_jumps  = "numeric"))
  
setClass("monster_truck",
  slots = list(mythical_backstory = "character"),
  contains = "truck")
  
getClass("monster_truck")
```

S4 objects have `slots`, accessible with `@` (which behaves like `$`) or `slot()`. We create new instances of S4 objects with `new()`

```{r}
my_truck <- new("truck", engine_size = 4, n_wheels = 4, n_jumps = 40)

my_truck@engine_size
slot(my_truck, "n_jumps")
```

S4 Methods are a headache (and we will skip them in the class). One has to create a generic function if it does not yet exist with `setGeneric()`, then set the method, classes and function separately with `setMethod()`. An example for your edification:

```{r}
setGeneric("go_faster", function(which_truck, how_fast) {standardGeneric("go_faster")})

setMethod("go_faster",
  signature = c(which_truck = "truck",
    how_fast = "character"),
  function(which_truck, how_fast){
    print("your truck is now going:")
    print(how_fast)
    print("in MPH:")
    print(which_truck@engine_size * 4)
  }
)

go_faster(my_truck, "2 fast 4 u 2 c")
```

Try extending that to have the monster trucks tell their mythical_backstory as they accelerate.

We will return to S4 objects in more detail in section 5.

# Reference Classes
http://adv-r.had.co.nz/OO-essentials.html#rc





# References
* http://manuals.bioinformatics.ucr.edu/home/programming-in-r#TOC-Object-Oriented-Programming-OOP-
* http://www.stat.ucla.edu/%7Ecocteau/stat202a/resources/docs/S4Objects.pdf
* http://adv-r.had.co.nz/OO-essentials.html


-------------------



